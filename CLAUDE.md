# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is "요괴의 성 탈출" (Yokai Castle Escape), a digital board game implementation of a classic 1980s Korean horror board game. The project transforms the original board game into a web-based interactive experience with modern web technologies.

## Development Commands

### Running the Game
```bash
cd yokai-game
python3 -m http.server 8000
# Then open http://localhost:8000 in browser
```

### Using npm scripts
```bash
npm start    # Starts development server on port 8000
npm run dev  # Same as start
```

### Testing
The project uses Playwright for automated testing:
```bash
npx playwright test                    # Run all tests
node simple-test.js                   # Run basic game tests
node full-game-test.js                # Run comprehensive game tests
node performance-test-final.js        # Run performance tests
```

### Development Tools
- Live server required for ES6 modules (cannot run directly from file system)
- Browser dev tools for debugging and performance monitoring
- Performance test files for optimization validation

## Architecture & File Structure

### Core Game Architecture
The game follows a modular ES6 architecture with clear separation of concerns:

- **Game Controller**: `src/js/game-original.js` - Main game state management
- **Board System**: `src/js/board-original.js` - Game board rendering and interaction
- **Card System**: `src/js/cards-new.js` - Card deck and game cards management
- **Board Data**: `src/js/boardData-original.js` - Static game board layout data

### Game State Management
The game uses a finite state machine pattern:
```javascript
const GameState = {
    SETUP: 'setup',
    PLAYING: 'playing', 
    MOVE_PHASE: 'move_phase',
    BATTLE_PHASE: 'battle_phase',
    GAME_OVER: 'game_over',
    VICTORY: 'victory'
};
```

### Board Layout System
- 25-room spiral layout on a 7x7 grid
- Room types: start, yokai rooms, safe zones, special rooms, escape
- Polar coordinate system for spiral connections
- CSS Grid-based positioning with precise room placement

### Performance Optimization
The project includes a sophisticated performance optimization system:

- **Animation Optimizer**: `src/js/animationOptimizer.js` - GPU-accelerated animations
- **Hardware Acceleration**: CSS transforms with `translateZ(0)` and `will-change`
- **Thread Management**: RequestAnimationFrame-based animation queuing
- **Memory Management**: Automatic performance mode switching based on device capabilities

### Card System Design
- Three card types: Yokai cards, Guardian cards, Item cards
- Weakness-based battle system (yokai have specific weaknesses)
- Visual card rendering with CSS animations
- Drag-and-drop interaction support

## Key Technical Patterns

### ES6 Module System
All JavaScript files use ES6 modules with explicit imports/exports. Always maintain this pattern when adding new functionality.

### CSS Architecture
- **Modular CSS**: Separate files for different game systems
- **CSS Custom Properties**: Used for theming and dynamic values
- **Grid-based Layout**: Board uses CSS Grid for precise positioning
- **Performance-first CSS**: Hardware acceleration applied to animated elements

### Event-Driven Architecture
The game uses custom event dispatching for component communication:
```javascript
// Dispatch game events
this.dispatchEvent(new CustomEvent('gameStateChange', { detail: newState }));
```

### Multiplayer Support
Built-in support for multiple game modes:
- Single player
- VS AI
- Hot-seat multiplayer (2 players)

## Testing Strategy

### Automated Testing
- **Playwright Tests**: Full browser automation for UI testing
- **Performance Tests**: Frame rate and memory usage monitoring
- **Game Flow Tests**: Complete gameplay scenario validation

### Manual Testing
- Visual regression testing using screenshot comparisons
- Cross-browser compatibility testing
- Mobile responsiveness testing

## Important Development Notes

### Performance Considerations
- All animations should use CSS transforms (not position changes)
- Use `will-change` property for elements that will animate
- Implement frame rate monitoring for performance-critical features
- Memory cleanup is essential for long gaming sessions

### Browser Compatibility
- Primary target: Modern browsers with ES6 module support
- Uses Web APIs: requestAnimationFrame, CSS Grid, CSS Custom Properties
- No polyfills included - assumes modern browser environment

### Game Balance
- Card deck composition is carefully balanced in `cards-new.js`
- Room distribution follows the original board game design
- Combat system uses weakness matching for strategy

## File Naming Conventions
- Original/legacy files: `-original.js` or `-original.css` suffix
- New/updated files: `-new.js` suffix or no suffix
- Test files: `*-test.js` or descriptive names like `simple-test.js`

## Visual Design System
- **Theme**: 1980s horror board game aesthetic with dark purple color scheme
- **Typography**: Korean language support required
- **Responsive Design**: Mobile-first approach with desktop enhancements
- **Animations**: Smooth CSS transitions with hardware acceleration

## Debugging & Troubleshooting
- Game state is accessible via `window.game` for console debugging
- Performance metrics available through AnimationOptimizer class
- Detailed bug reports available in `GAME_BUG_REPORT.md`
- Optimization documentation in `OPTIMIZATION_SUMMARY.md`

## Production Considerations
- Static file serving (no backend required)
- Optimized for CDN deployment
- Memory management for extended play sessions
- Performance monitoring and automatic optimization

# GEMINI.md - 프로젝트 규칙

이 문서는 Gemini를 사용하여 이 프로젝트와 상호 작용할 때 따라야 할 규칙과 가이드를 정의합니다.

- 시니어 풀스택 개발자로서 신중하고 상세한 답변을 제공해 주세요.
- Always respond in 한글
  
1. 사전 분석 단계
🔍 프로젝트 심층 분석 (필수 우선 실행)
RULE: 코드 작성 전 반드시 다음을 수행하라
1.1 프로젝트 구조 파악
디렉토리 구조와 파일 명명 규칙 분석
기존 아키텍처 패턴 식별 (MVC, Clean Architecture 등)
의존성 관리 방식 확인 (package.json, requirements.txt 등)

1.2 코딩 컨벤션 확인

기존 코드의 스타일 가이드 추출
변수명, 함수명 패턴 분석
들여쓰기, 괄호 스타일 등 포맷팅 규칙 파악

1.3 기술 스택 이해

사용 중인 프레임워크와 라이브러리 목록 작성
버전 호환성 및 제약사항 확인
외부 API 및 데이터베이스 연동 방식 파악

2. 코드 작성 원칙
💎 DRY 원칙과 SOLID 원칙, 가독성 우선
RULE: 중복 코드 제거와 가독성을 동시에 추구하라
2.1 함수/메서드 설계

단일 책임 원칙: 하나의 함수는 하나의 기능만 수행
의미있는 네이밍: getUserData() ✅ vs getData() ❌
적절한 길이: 15줄 이내 권장, 최대 30줄 초과 금지

2.2 성능 고려사항
반복문 최적화: 불필요한 중첩 반복 제거
메모리 효율성: 대용량 데이터 처리 시 스트리밍 방식 고려
네트워크 호출: 배치 처리 및 캐싱 전략 적용

3. 구조화 및 설계
🏗️ 모듈화와 폴더 구조
RULE: 기능별 폴더 분리와 모듈화를 강제하라

3.1 의존성 관리
높은 의존성 코드 분리: 외부 API, 데이터베이스 연결 등
인터페이스 활용: 의존성 주입을 통한 느슨한 결합
환경별 설정 분리: development, staging, production

4. 품질 보증
✅ 코드 품질 검증
RULE: 작성 중 실시간 품질 검증을 수행하라
4.1 실시간 검증 항목

문법 오류 및 타입 오류 즉시 탐지
사용하지 않는 변수/함수 식별
잠재적 보안 취약점 스캔 (SQL 인젝션, XSS 등)

4.2 코드 복잡도 관리

순환 복잡도(Cyclomatic Complexity) 10 이하 유지
중첩 깊이 3단계 이하 권장
함수 매개변수 5개 이하 제한

5. 문서화 및 주석
📝 의미있는 문서화
RULE: 코드가 '무엇을'이 아닌 '왜'를 설명하라

6. 테스트 및 검증
🧪 테스트 주도 개발
RULE: 핵심 비즈니스 로직은 테스트 코드로 검증하라
7.1 테스트 작성 우선순위

핵심 비즈니스 로직 - 반드시 테스트 작성
에러 처리 로직 - 예외 상황 테스트
외부 연동 부분 - 모킹을 통한 테스트
단순 CRUD - 선택적 테스트

🎯 Roo Code 실행 체크리스트
코드 작성 전 (Pre-coding)

 프로젝트 구조 및 기존 패턴 분석 완료
 요구사항 명확히 이해하고 구현 계획 수립
 필요한 의존성 및 라이브러리 확인

코드 작성 중 (During-coding)

 함수별로 단일 책임 원칙 준수
 의미있는 변수명과 함수명 사용
 주요 로직에 목적 설명 주석 추가
 에러 처리 및 로깅 구현

코드 작성 후 (Post-coding)

 중복 코드 제거 및 리팩토링
 테스트 코드 작성 (핵심 로직)
 코드 품질 검증 (린팅, 타입 체크)
 문서화 및 예제 코드 작성

🚀 주니어 개발자를 위한 팁
1. 코드 작성은 글쓰기와 비슷합니다

문단(함수)별로 하나의 주제만 다루세요
읽는 사람이 이해하기 쉽게 써주세요
중요한 부분에는 설명(주석)을 달아주세요

2. 에러는 친구입니다

에러 메시지를 잘 읽어보세요
사용자에게 도움이 되는 메시지를 제공하세요
로그를 통해 문제 추적이 가능하게 하세요

3. 테스트는 보험입니다

코드가 의도대로 동작하는지 확인해주세요
미래의 자신이 고마워할 거예요


MCP의 AoT(Atom of Thoughts) 를 사용해서 코드를 작성해주세요.


### 생각 정리하기 
"단계별로 차근차근 생각해봅시다."
"답변하기 전에 모든 추론 과정을 보여주세요."
"심호흡을 하고 신중하게 작업해봅시다."
"천천히 논리적으로 접근하면서 각 단계가 타당한지 확인해봅시다."
"심호흡을 하고 정확한 답을 얻기 위해 단계별로 차근차근 해결해봅시다."
"[분야]의 최고 전문가처럼 생각해보세요. 그들이 사용할 모든 관련 요소와 방법론을 고려해봅시다."
"답변의 어떤 부분에 대해 확신이 서지 않는다면, 불확실성을 명확히 밝히고 그 이유를 설명해주세요."
"이 문제를 다각도(예: 경제적, 사회적, 윤리적)에서 분석해봅시다. 각 관점에서의 장단점은 무엇일까요?"
"해결책을 제안하기 전에, 먼저 이 문제의 근본 원인과 전제 가정들을 파악해봅시다."
"[구체적 질문 X]에 답하기 전에, 먼저 [더 넓은 주제 Y]와 관련된 일반적인 원리나 개념들을 살펴봅시다."
"초안 답변을 작성해보세요. 그 다음 잠재적 편향, 부정확성, 개선 영역에 대해 자신의 답변을 비판적으로 검토하세요. 마지막으로 수정되고 개선된 답변을 제공해주세요."
"이것은 복잡한 문제입니다. [3-5]개의 작고 관리 가능한 하위 문제로 나누어봅시다. 각 하위 문제를 체계적으로 해결해봅시다."

### 항상 MCP를 활용할 준비를 할 것!

🔧 범용 MCP 도구 활용 최적화 프롬프트
🎯 핵심 원칙
"도구함을 열기 전에 먼저 도구함 안을 파악하라"

구체적인 도구 이름을 미리 알 필요가 없습니다. 중요한 것은 자신이 가진 도구를 스스로 파악하고 최적으로 활용하는 방법론입니다.

📋 5단계 범용 방법론
🔍 1단계: 자기 진단 (Self-Assessment)
"내가 가진 도구가 무엇인지 먼저 파악하기"

🔍 도구 탐색 방법:
□ 사용 가능한 모든 function/tool 목록 확인
□ 각 도구의 기본 설명과 파라미터 파악
□ 도구별 주요 기능과 제약사항 이해
□ 유사한 기능을 가진 도구들 그룹핑

💡 자기 질문:
- "현재 내가 사용할 수 있는 도구는 몇 개인가?"
- "각 도구는 무엇을 할 수 있는가?"
- "어떤 도구들이 비슷한 기능을 제공하는가?"
🏷️ 2단계: 기능별 분류 (Categorization)
"비슷한 도구끼리 그룹핑하기"

📂 일반적인 카테고리 예시:

🧠 분석/사고 도구
- 복잡한 로직 분석
- 계산 및 데이터 처리
- 문제 해결 지원

💻 개발/코드 도구
- 코드 작성/편집
- 버전 관리
- 터미널/명령어 실행

📊 데이터/저장 도구
- 데이터베이스 작업
- 파일 시스템 조작
- 데이터 변환/처리

🌐 웹/통신 도구
- 정보 검색
- 웹 페이지 접근
- API 호출

🎨 특수 목적 도구
- 디자인 관련
- 프로젝트 관리
- 문서화 지원

⚠️ 중요: 자신의 도구를 이 분류에 억지로 맞추지 말고, 
실제 기능을 기준으로 유연하게 분류하세요!
🎯 3단계: 요구사항 매핑 (Requirement Mapping)
"해야 할 일과 도구 연결하기"

🎯 매핑 프로세스:

1️⃣ 작업 분해
- 큰 작업을 작은 단위로 나누기
- 각 단위별 필요한 기능 정의
- 우선순위 설정

2️⃣ 도구-기능 매칭
- 각 작업에 적합한 도구 후보 찾기
- 여러 도구가 필요한 경우 조합 고려
- 대안 도구 옵션 확인

3️⃣ 의존관계 파악
- 어떤 도구의 출력이 다른 도구의 입력이 되는가?
- 순서가 중요한 작업들은?
- 병렬 처리 가능한 작업들은?

💡 매핑 예시 템플릿:
작업: [구체적인 작업]
├── 필요 기능: [요구되는 기능]
├── 후보 도구: [가능한 도구들]
├── 추천 도구: [최적 선택]
└── 대안: [플랜 B]
⚡ 4단계: 동적 선택 (Dynamic Selection)
"상황에 맞는 최적 조합 찾기"

🎛️ 선택 기준:

효율성 우선
□ 가장 직접적으로 목표를 달성하는 도구는?
□ 중간 단계를 줄일 수 있는 도구 조합은?
□ 시간이 가장 적게 걸리는 방법은?

신뢰성 우선
□ 가장 안정적이고 검증된 도구는?
□ 실패 가능성이 낮은 조합은?
□ 문제 발생 시 대안이 있는 선택은?

확장성 우선
□ 나중에 기능을 추가하기 쉬운 구조는?
□ 재사용 가능한 컴포넌트를 만들 수 있는가?
□ 유지보수가 용이한 선택은?

🔄 동적 조정 원칙:
- 진행 중에도 더 나은 도구를 발견하면 변경 고려
- 예상보다 복잡해지면 더 강력한 도구로 전환
- 단순한 작업에는 복잡한 도구 사용 지양
✅ 5단계: 검증 및 최적화 (Validation & Optimization)
"선택한 도구가 정말 최선인지 확인하기"

🔍 검증 체크리스트:

기능적 검증
□ 선택한 도구들이 실제로 요구사항을 만족하는가?
□ 예상치 못한 제약사항은 없는가?
□ 모든 엣지 케이스를 처리할 수 있는가?

효율성 검증
□ 불필요한 도구 사용은 없는가?
□ 더 간단한 대안은 정말 없는가?
□ 도구 간 데이터 전달 오버헤드는 적절한가?

실용성 검증
□ 실제로 구현 가능한 선택인가?
□ 시간과 리소스 제약 내에서 실행 가능한가?
□ 팀원들도 이해하고 사용할 수 있는가?

🔧 최적화 방법:
- 중복 기능 제거
- 도구 조합 간소화
- 병목 지점 해결
- 예외 처리 강화
🚀 실전 적용 템플릿
📝 단계별 실행 가이드
markdown
## 🔍 1단계: 내 도구 파악
[ ] 사용 가능한 모든 도구 나열
[ ] 각 도구의 핵심 기능 3줄 요약
[ ] 유사 기능 도구들 그룹핑

## 🏷️ 2단계: 카테고리 분류
[ ] 분석/사고: [해당 도구들]
[ ] 개발/코드: [해당 도구들]  
[ ] 데이터/저장: [해당 도구들]
[ ] 웹/통신: [해당 도구들]
[ ] 기타 특수: [해당 도구들]

## 🎯 3단계: 작업 매핑
목표: [구체적인 목표]
├── 세부 작업 1: [필요 도구]
├── 세부 작업 2: [필요 도구]
└── 세부 작업 3: [필요 도구]

## ⚡ 4단계: 최적 조합 선택
선택한 도구: [도구1] + [도구2] + [도구3]
선택 이유: [구체적인 근거]
대안 계획: [플랜 B]

## ✅ 5단계: 최종 검증
[ ] 기능적으로 문제없는가?
[ ] 효율적인 선택인가?
[ ] 실제 구현 가능한가?
💡 범용 활용 팁
🎯 상황별 접근법
🚀 빠른 프로토타입이 필요할 때:

복잡한 도구 조합보다 단일 강력한 도구 선호
완벽함보다 빠른 결과 우선
나중에 최적화할 수 있는 구조로 설계
🔒 안정성이 중요할 때:

검증된 도구 조합 선택
예외 처리가 강한 도구 선호
백업 계획 항상 준비
📈 확장성이 중요할 때:

모듈화된 도구 사용
재사용 가능한 컴포넌트 우선
표준화된 인터페이스 활용
⚠️ 자주 하는 실수들
도구 과잉: "더 많은 도구 = 더 좋은 결과"라는 착각
도구 의존: 도구 없이는 할 수 없다고 생각하는 고정관념
일관성 부족: 비슷한 작업에 매번 다른 도구 조합 사용
검증 생략: 도구 선택 후 바로 구현에 돌입
🎯 마무리 질문 세트
구현 전 반드시 답해야 할 질문들:

🔍 도구 이해도 점검
"내가 선택한 각 도구의 핵심 기능을 한 문장으로 설명할 수 있는가?"
"이 도구를 선택한 구체적인 이유 3가지는 무엇인가?"
⚡ 효율성 점검
"더 간단한 방법으로도 같은 결과를 얻을 수 있지 않은가?"
"이 도구 조합이 정말 최적인가, 아니면 익숙해서 선택한 것인가?"
🔮 확장성 점검
"6개월 후에도 이 선택을 후회하지 않을 것인가?"
"다른 사람이 이 구조를 이해하고 사용할 수 있을 것인가?"
이 프롬프트는 어떤 환경의 AI 모델이든 자신이 가진 MCP 도구를 효율적으로 파악하고 활용할 수 있도록 설계된 범용 프레임워크입니다. 구체적인 도구 이름에 의존하지 않고, 방법론과 원칙에 집중하여 지속 가능한 활용이 가능합니다.

# 개발 협업 가이드라인

우리는 함께 프로덕션 수준의 코드를 개발하고 있습니다. 여러분의 역할은 유지보수 가능하고 효율적인 솔루션을 만들면서 잠재적인 문제를 미리 발견하는 것입니다.

제가 복잡하거나 막혀있는 것 같으면 방향을 잡아드릴 것이며, 제 가이드는 여러분이 목표에 집중할 수 있도록 도와줍니다.

## 🚨 자동화된 검사는 필수입니다

**모든 후크(hook) 문제는 차단 대상 - 모든 것이 ✅ 녹색이어야 합니다!**

오류 없음. 포맷팅 문제 없음. 린팅 문제 없음. 절대 용인하지 않습니다.
이는 제안이 아닙니다. 계속 진행하기 전에 모든 문제를 해결하세요.

## 핵심 워크플로우 - 반드시 이 순서를 따르세요!

### 조사 → 계획 → 구현

**절대로 코딩에 바로 뛰어들지 마세요!** 다음 순서를 항상 따르세요:

1. **조사**: 코드베이스 탐색, 기존 패턴 이해
2. **계획**: 상세한 구현 계획 수립 및 제게 확인 요청
3. **구현**: 검증 지점과 함께 계획 실행

어떤 기능을 구현해야 할 때는 먼저 말씀드립니다: "구현 전에 코드베이스를 조사하고 계획을 세우겠습니다."

복잡한 아키텍처 결정이나 도전적인 문제의 경우, 최대한의 추론 능력을 발휘하기 위해 **"초고도 사고(ultrathink)"**를 사용합니다. "이 아키텍처에 대해 해결책을 제안하기 전에 깊이 생각해보겠습니다."

### 여러 에이전트 활용!

더 나은 결과를 위해 *하위 에이전트를 적극적으로 활용*:

- 코드베이스의 여러 부분을 병렬로 탐색하는 에이전트 생성
- 한 에이전트는 테스트를 작성하고 다른 에이전트는 기능 구현
- 조사 작업 위임: "데이터베이스 스키마를 조사할 에이전트를 보내는 동안 API 구조를 분석하겠습니다"
- 복잡한 리팩토링의 경우: 한 에이전트는 변경 사항 식별, 다른 에이전트는 구현

여러 독립적인 부분이 있는 작업의 경우 "이 문제의 다른 측면을 처리할 에이전트를 생성하겠습니다"라고 말하세요.

### 현실 검증 지점

다음 순간에 **멈추고 검증**:

- 완전한 기능 구현 후
- 새로운 주요 구성 요소 시작 전
- 뭔가 잘못된 것 같을 때
- "완료" 선언 전
- **후크가 오류와 함께 실패할 때** ❌

실행: `make fmt && make test && make lint`

> 이유: 실제로 작동하는 것을 놓칠 수 있습니다. 이러한 검증 지점은 연쇄 실패를 방지합니다.
> 

### 🚨 중요: 후크 실패는 차단됩니다

**후크가 어떤 문제라도 보고하면(종료 코드 2) 반드시 다음을 수행해야 합니다:**

1. **즉시 중단** - 다른 작업 진행 금지
2. **모든 문제 해결** - 모든 ❌ 문제를 해결할 때까지 처리
3. **수정 확인** - 실패한 명령을 다시 실행하여 해결 확인
4. **원래 작업 계속** - 중단 전 하던 작업으로 돌아가기
5. **절대 무시 금지** - 경고 없음, 오직 요구사항만 존재

여기에는 다음이 포함됩니다:

- 포맷팅 문제 (gofmt, black, prettier 등)
- 린팅 위반 (golangci-lint, eslint 등)
- 금지된 패턴 (time.Sleep, panic(), interface{})
- 기타 모든 검사

코드는 100% 깨끗해야 합니다. 예외 없음.

**복구 프로토콜:**

- 후크 실패로 중단된 경우, 원래 작업에 대한 인식 유지
- 모든 문제 해결 및 수정 확인 후, 중단된 지점부터 계속 진행
- TODO 목록을 사용하여 수정 및 원래 작업 추적

## 작업 메모리 관리

### 컨텍스트가 길어질 때:

- [CLAUDE.md](http://claude.md/) 파일 다시 읽기
- [PROGRESS.md](http://progress.md/) 파일에 진행 상황 요약
- 주요 변경 전 현재 상태 문서화

### [TODO.md](http://todo.md/) 유지 관리:

```
## 현재 작업
- [ ] 지금 하고 있는 것

## 완료
- [x] 실제로 완료되고 테스트된 것

## 다음 단계
- [ ] 다음에 할 일

```

## Go 언어 특화 규칙

### 금지 - 절대 하지 마세요:

- **interface{}** 또는 **any{}** 사용 금지 - 구체적인 타입 사용!
- **time.Sleep()** 또는 바쁜 대기 금지 - 동기화에는 채널 사용!
- 구형과 신형 코드를 함께 보관 금지
- 마이그레이션 함수 또는 호환성 계층 금지
- 버전이 붙은 함수 이름 금지 (processV2, handleNew)
- 사용자 정의 오류 구조체 계층 금지
- 최종 코드에 TODO 금지

> 자동화된 집행: 스마트-린트 후크는 이러한 규칙을 위반하는 커밋을 차단합니다.
> 
> 
> `❌ 금지된 패턴`을 보면 즉시 수정해야 합니다!
> 

### 필수 표준:

- 대체 시 이전 코드 삭제
- 의미 있는 이름: `userID`와 같이 사용, `id` 금지
- 중첩 줄이기 위한 조기 반환
- 생성자의 구체적인 타입: `func NewServer() *Server`
- 간단한 오류: `return fmt.Errorf("context: %w", err)`
- 복잡한 로직은 테이블 기반 테스트
- 동기화에 채널 사용: sleep 대신 채널로 준비 신호
- 타임아웃에는 select 사용: sleep 루프 대신 타임아웃 채널과 select 사용

## 구현 표준

### 우리의 코드가 완성된 상태:

- ? 모든 린터 통과 (문제 없음)
- ? 모든 테스트 통과
- ? 엔드투엔드 기능 작동
- ? 이전 코드 삭제
- ? 모든 외부 공개 심볼에 Godoc 작성

### 테스트 전략

- 복잡한 비즈니스 로직? 먼저 테스트 작성
- 단순 CRUD? 이후에 테스트 작성
- 핵심 경로? 벤치마크 추가
- main() 및 간단한 CLI 파싱은 테스트 생략

### 프로젝트 구조

```
cmd/        # 애플리케이션 진입점
internal/   # 비공개 코드 (대부분의 코드가 여기 위치)
pkg/        # 공개 라이브러리 (진정으로 재사용 가능한 경우에만)

```

## 함께 문제 해결하기

막히거나 혼란스러울 때:

1. **멈추기** - 복잡한 해결책으로 빠져들지 마세요
2. **위임** - 병렬 조사를 위한 에이전트 고려
3. **초고도 사고** - 복잡한 문제의 경우 "이 도전을 깊이 생각해야 합니다"라고 말해 더 깊은 추론 유도
4. **뒤로 물러서기** - 요구사항 다시 읽기
5. **단순화** - 대개 간단한 해결책이 정확합니다
6. **질문하기** - "두 가지 접근법을 보았습니다: [A] 대 [B]. 어느 것을 선호하시나요?"

더 나은 접근 방식에 대한 제 통찰을 귀중하게 여깁니다 - 주저 말고 물어보세요!

## 성능 & 보안

### **먼저 측정**:

- 성급한 최적화 금지
- 더 빠르다고 주장하기 전에 벤치마크
- 실제 병목 지점은 pprof 사용

### **보안 최우선**:

- 모든 입력 검증
- 무작위성은 crypto/rand 사용
- SQL에는 prepared statements (절대 문자열 연결 금지!)

## 커뮤니케이션 프로토콜

### 진행 상황 업데이트:

```
✓ 인증 구현 (모든 테스트 통과)
✓ 속도 제한 추가
✗ 토큰 만료 문제 발견 - 조사 중

```

### 개선 제안:

"현재 접근 방식은 작동하지만, [관찰 내용]을 발견했습니다.
[구체적 개선 사항]을 진행하길 원하시나요?"

## 협업 방식

- 항상 기능 브랜치에서 작업 - 이전 버전과의 호환성 불필요
- 확신이 서지 않으면 영리함보다 명확성 선택
- **알림**: 이 파일을 30분 이상 참조하지 않았다면 다시 읽으세요!

복잡한 추상화나 "영리한" 코드는 피하세요. 간단하고 명확한 해결책이 대개 더 좋으며, 제 가이드는 중요한 것에 집중하도록 도와줍니다.




### 테스트를 위해 playwright mcp를 적극 활용하세요.
- playwright 도구 사용법 사전 숙지하기
- 툴 사용을 위해 계획 세우기
- 계획에 따라 테스트 진행, 오류 및 버그 추적
- 수정 후 다시 테스트를 진행( 오류 및 버그가 사라질 때까지 이 과정 반복)

🎯 핵심 디버깅 철학
RULE: 증상을 치료하지 말고 병의 원인을 찾아라
1.1 체계적 접근 원칙
비유: 의사가 환자를 진료하는 것처럼 체계적으로 접근하세요

관찰 우선: 감정이나 추측보다는 객관적 사실 수집
가설 기반: 모든 가능한 원인을 나열한 후 우선순위 설정
실험적 검증: 각 가설을 하나씩 체계적으로 테스트
증거 기반 결론: 충분한 증거가 있을 때만 결론 도출

1.2 재현 가능성 원칙
RULE: 재현할 수 없는 버그는 해결할 수 없다
재현 가능한 버그 리포트 구성 요소:

명확한 문제 정의: 무엇이 잘못되었는지 한 문장으로 설명
정확한 재현 단계: 다른 사람이 따라할 수 있을 정도로 구체적
환경 정보: 운영체제, 브라우저, 앱 버전, 네트워크 상태 등
예상 vs 실제 결과: 정상 동작과 비정상 동작의 명확한 구분
빈도 및 패턴: 항상 발생하는지, 특정 조건에서만 발생하는지

1.3 점진적 축소 원칙
RULE: 복잡한 문제를 작은 단위로 나누어 해결하라
문제 범위 축소 전략:

이진 탐색 방식: 전체를 절반씩 나누어 문제 영역 좁히기
계층별 접근: 시스템 → 모듈 → 함수 → 라인 순으로 범위 축소
시간적 접근: 언제부터 문제가 시작되었는지 추적
격리 테스트: 의심되는 부분만 별도로 테스트

2. DERIVE 6단계 프로세스
🔍 1단계: DETECT (문제 감지)
RULE: 정확한 문제 정의가 해결의 절반이다
문제 분류 프레임워크:
에러 유형 분류:
├── 런타임 에러
│   ├── 메모리 관련 (null 참조, 메모리 부족)
│   ├── 타입 관련 (잘못된 캐스팅, 타입 불일치)
│   └── 리소스 관련 (파일 없음, 네트워크 연결 실패)
├── 로직 에러
│   ├── 계산 오류 (잘못된 공식, 반올림 문제)
│   ├── 조건 오류 (잘못된 if문, 논리 연산자 실수)
│   └── 흐름 오류 (무한루프, 잘못된 제어 구조)
├── 성능 문제
│   ├── 응답 지연 (느린 쿼리, 비효율한 알고리즘)
│   ├── 리소스 누수 (메모리 누수, 연결 미해제)
│   └── 병목 현상 (동시성 문제, I/O 대기)
└── 사용자 경험 문제
    ├── UI/UX 문제 (화면 깨짐, 사용 불편)
    ├── 접근성 문제 (키보드 접근 불가, 스크린 리더 미지원)
    └── 호환성 문제 (브라우저별, 디바이스별 차이)
심각도 평가 매트릭스:
심각도 평가 기준:
Critical: 시스템 완전 중단, 데이터 손실, 보안 위험
High: 핵심 기능 장애, 다수 사용자 영향, 비즈니스 중단
Medium: 일부 기능 제한, 성능 저하, 우회 방법 존재
Low: 사소한 불편, 비핵심 기능 영향, 사용자 적응 가능
📊 2단계: EXTRACT (정보 추출)
RULE: 충분한 정보 없이는 정확한 진단이 불가능하다
체계적 정보 수집 체크리스트:
시스템 환경 정보:
□ 운영체제 및 버전
□ 하드웨어 사양 (CPU, 메모리, 디스크)
□ 네트워크 환경 및 대역폭
□ 설치된 소프트웨어 및 버전

애플리케이션 정보:
□ 애플리케이션 버전 및 빌드 번호
□ 설정 파일 및 환경 변수
□ 의존성 라이브러리 버전
□ 최근 변경 이력 (코드, 설정, 배포)

런타임 정보:
□ 에러 메시지 및 스택 트레이스
□ 로그 파일 (애플리케이션, 시스템, 웹서버)
□ 성능 메트릭 (CPU, 메모리, 디스크, 네트워크 사용량)
□ 사용자 행동 패턴 및 입력 데이터

외부 요인:
□ 외부 서비스 상태 (API, 데이터베이스, 클라우드)
□ 네트워크 상태 및 방화벽 설정
□ 동시 사용자 수 및 트래픽 패턴
□ 시간대별 변화 (피크 시간, 업데이트 시점)
로그 분석 전략:
로그 분석 우선순위:
1. 에러 로그 → 경고 로그 → 정보 로그 순서로 검토
2. 시간순 분석 → 문제 발생 전후 상황 파악
3. 패턴 식별 → 반복되는 에러나 특정 조건 확인
4. 상관관계 분석 → 여러 이벤트 간의 연관성 파악
🧠 3단계: REASON (추론)
RULE: 모든 가능한 원인을 나열한 후 우선순위를 정하라
가설 수립 프레임워크:
가설 생성 방법:
1. 최근 변경사항 기반
   - 새로운 코드 배포
   - 시스템 설정 변경
   - 의존성 업데이트

2. 에러 패턴 기반
   - 에러 메시지 키워드 분석
   - 스택 트레이스 경로 추적
   - 재현 조건 분석

3. 시스템 상태 기반
   - 리소스 사용량 급증
   - 외부 서비스 장애
   - 네트워크 연결 문제

4. 비즈니스 로직 기반
   - 데이터 유효성 검증
   - 권한 및 보안 규칙
   - 워크플로우 오류
가설 우선순위 설정 기준:
우선순위 매트릭스:
높은 우선순위:
- 높은 발생 확률 + 높은 영향도
- 최근 변경사항과 직접 연관
- 명확한 증거가 있는 가설

중간 우선순위:
- 중간 발생 확률 + 중간 영향도
- 과거 유사한 문제 발생 이력
- 일부 증거가 있는 가설

낮은 우선순위:
- 낮은 발생 확률 + 낮은 영향도
- 추상적이고 증거가 부족한 가설
- 복잡한 검증이 필요한 가설
5 Why 기법 적용:
5 Why 분석 예시:
문제: 사용자가 앱에 로그인할 수 없음
Why 1: 왜 로그인이 안 되는가? → 서버가 응답하지 않음
Why 2: 왜 서버가 응답하지 않는가? → 데이터베이스 연결 실패
Why 3: 왜 DB 연결이 실패하는가? → 연결 풀이 모두 사용됨
Why 4: 왜 연결 풀이 고갈되는가? → 연결이 반환되지 않음
Why 5: 왜 연결이 반환되지 않는가? → 개발자가 finally 블록 누락

근본 원인: 리소스 관리 코드 누락
해결 방향: 자동 리소스 관리 패턴 적용
🔬 4단계: INVESTIGATE (조사)
RULE: 하나씩 체계적으로 검증하며 성급한 결론을 피하라
가설 검증 전략:
검증 방법론:
1. 격리 테스트
   - 의심되는 컴포넌트만 별도 실행
   - 단위 테스트로 개별 함수 검증
   - 모의 객체(Mock)로 외부 의존성 제거

2. 점진적 추가
   - 최소한의 코드부터 시작
   - 하나씩 컴포넌트 추가하며 테스트
   - 문제 발생 지점 정확히 식별

3. 비교 분석
   - 정상 환경과 문제 환경 비교
   - 정상 데이터와 문제 데이터 비교
   - 이전 버전과 현재 버전 비교

4. 실험적 접근
   - 가설을 증명할 수 있는 실험 설계
   - 변수를 하나씩 조작하며 관찰
   - 결과를 정량적으로 측정
디버깅 도구 활용 원칙:
도구 선택 기준:
1. 문제 유형에 맞는 도구 선택
   - 메모리 문제 → 메모리 프로파일러
   - 성능 문제 → 성능 모니터링 툴
   - 네트워크 문제 → 패킷 분석기

2. 비침습적 도구 우선 사용
   - 프로덕션 환경에 영향 최소화
   - 실행 중인 시스템 중단 없이 분석
   - 오버헤드가 적은 모니터링 도구

3. 계층별 접근
   - 상위 레벨: 시스템 전체 모니터링
   - 중간 레벨: 애플리케이션 수준 분석
   - 하위 레벨: 코드 라인별 상세 분석
✅ 5단계: VERIFY (검증)
RULE: 해결책이 실제로 문제를 해결했는지 반드시 확인하라
해결책 검증 체크리스트:
검증 항목:
□ 원본 문제가 실제로 해결되었는가?
□ 새로운 문제가 발생하지 않았는가?
□ 기존 기능에 영향을 주지 않았는가?
□ 성능에 부정적 영향이 없는가?
□ 다양한 환경에서 동일하게 작동하는가?
□ 경계 조건에서도 정상 작동하는가?
□ 사용자 경험이 개선되었는가?
□ 보안상 새로운 취약점이 생기지 않았는가?
검증 방법론:
검증 단계:
1. 단위 테스트 실행
   - 수정된 함수/모듈의 개별 테스트
   - 경계값 및 예외 상황 테스트

2. 통합 테스트 실행
   - 수정된 부분과 연관된 모듈 간 테스트
   - 데이터 플로우 및 인터페이스 검증

3. 시스템 테스트 실행
   - 전체 시스템 관점에서의 기능 검증
   - 사용자 시나리오 기반 E2E 테스트

4. 성능 테스트 실행
   - 부하 테스트로 성능 영향 측정
   - 리소스 사용량 모니터링

5. 사용자 승인 테스트
   - 실제 사용자 환경에서 검증
   - 사용성 및 만족도 평가
📚 6단계: EDUCATE (학습)
RULE: 해결 과정을 문서화하여 미래의 자신과 팀을 도우라
학습 문서화 템플릿:
디버깅 보고서 구조:
1. 문제 요약
   - 발생 시간 및 지속 기간
   - 영향 범위 및 심각도
   - 핵심 증상 한 줄 요약

2. 문제 상세 분석
   - 구체적인 증상 및 에러 메시지
   - 재현 단계 및 조건
   - 수집된 정보 및 데이터

3. 원인 분석
   - 수립했던 가설들
   - 검증 과정 및 결과
   - 최종 확인된 근본 원인

4. 해결 과정
   - 적용한 해결책 상세 설명
   - 구현 방법 및 고려사항
   - 검증 과정 및 결과

5. 예방 조치
   - 재발 방지를 위한 조치
   - 모니터링 강화 방안
   - 프로세스 개선 사항

6. 교훈 및 학습
   - 이번 경험에서 배운 점
   - 팀 차원의 개선 방향
   - 유사 문제 예방 가이드
3. 문제 유형별 접근 전략
🚨 런타임 에러 접근법
3.1 메모리 관련 에러
접근 전략:
1. 메모리 사용 패턴 분석
   - 메모리 할당/해제 추적
   - 참조 관계 및 생명주기 검토
   - 메모리 프로파일링 도구 활용

2. 일반적인 원인 확인
   - Null/빈 참조 접근
   - 초기화되지 않은 변수 사용
   - 잘못된 메모리 주소 접근
   - 메모리 누수로 인한 부족

3. 예방 및 해결 패턴
   - 방어적 프로그래밍 (null 체크)
   - 자동 메모리 관리 활용
   - 리소스 사용 후 명시적 해제
   - 메모리 사용량 모니터링
3.2 타입 관련 에러
접근 전략:
1. 타입 시스템 활용
   - 정적 타입 검사 도구 사용
   - 타입 힌트 및 어노테이션 추가
   - 컴파일 타임 검증 강화

2. 데이터 흐름 추적
   - 입력 데이터 타입 검증
   - 변환 과정에서 타입 변화 추적
   - API 경계에서 타입 검증

3. 안전한 타입 처리
   - 타입 검사 후 사용
   - 안전한 타입 변환 사용
   - 기본값 및 대체값 준비
⚡ 성능 문제 접근법
3.3 응답 지연 문제
분석 접근법:
1. 병목 지점 식별
   - 전체 프로세스 플로우 매핑
   - 각 단계별 소요 시간 측정
   - 가장 느린 구간 우선 개선

2. 리소스 사용량 분석
   - CPU, 메모리, 디스크, 네트워크 사용률
   - 동시성 및 대기 시간 분석
   - 외부 의존성 응답 시간

3. 최적화 전략
   - 알고리즘 효율성 개선
   - 캐싱 전략 적용
   - 병렬 처리 도입
   - 불필요한 작업 제거
4. 정보 수집 방법론
📊 체계적 데이터 수집
4.1 로그 기반 분석
효과적인 로깅 전략:
1. 구조화된 로그 형식
   - 일관된 로그 포맷 사용
   - 타임스탬프, 로그 레벨, 컨텍스트 포함
   - 기계가 읽기 쉬운 형태 (JSON 등)

2. 적절한 로그 레벨
   - ERROR: 시스템 오류, 처리 불가능한 상황
   - WARN: 주의가 필요한 상황, 잠재적 문제
   - INFO: 일반적인 작업 흐름, 주요 이벤트
   - DEBUG: 상세한 실행 정보, 개발 시에만 활성화

3. 컨텍스트 정보 포함
   - 요청 ID로 관련 로그 연결
   - 사용자 정보 (개인정보 제외)
   - 실행 환경 및 버전 정보
   - 관련 데이터 및 매개변수
4.2 메트릭 기반 모니터링
핵심 메트릭 카테고리:
1. 시스템 메트릭
   - CPU 사용률 및 부하
   - 메모리 사용량 및 가용량
   - 디스크 I/O 및 여유 공간
   - 네트워크 트래픽 및 대역폭

2. 애플리케이션 메트릭
   - 응답 시간 및 처리량
   - 에러율 및 성공률
   - 동시 사용자 수
   - 큐 길이 및 대기 시간

3. 비즈니스 메트릭
   - 주요 기능 사용률
   - 사용자 이탈률
   - 트랜잭션 성공률
   - 매출 및 전환율
5. 가설 수립 및 검증
🧪 과학적 접근법
5.1 가설 수립 방법론
가설 설계 원칙:
1. 구체적이고 측정 가능한 가설
   - 모호한 표현 대신 구체적 기준 제시
   - 검증 가능한 조건 명시
   - 예상 결과 명확히 정의

2. 검증 비용 고려
   - 검증하기 쉬운 가설부터 우선
   - 리스크가 낮은 실험부터 진행
   - 시간과 리소스 효율성 고려

3. 상호 배타적 가설 구성
   - 하나의 가설이 맞으면 다른 것은 틀린 구조
   - 명확한 판단 기준 설정
   - 애매한 중간 상태 최소화
5.2 실험 설계 전략
실험 설계 요소:
1. 통제 변수 설정
   - 한 번에 하나의 변수만 변경
   - 다른 조건은 동일하게 유지
   - 외부 요인 영향 최소화

2. 측정 기준 정의
   - 정량적 측정 지표 설정
   - 성공/실패 판단 기준 명확화
   - 측정 방법 및 도구 준비

3. 실험 환경 구성
   - 프로덕션과 유사한 환경 구성
   - 재현 가능한 조건 설정
   - 안전한 실험 환경 확보
6. 도구 선택 및 활용
🛠️ 도구 활용 전략
6.1 도구 선택 기준
선택 기준 매트릭스:
1. 문제 적합성
   - 해결하려는 문제 유형과 일치
   - 필요한 기능 및 정확도 제공
   - 환경 및 플랫폼 호환성

2. 사용 편의성
   - 학습 곡선 및 숙련 시간
   - 인터페이스 직관성
   - 문서화 품질 및 커뮤니티 지원

3. 비용 효율성
   - 라이선스 비용 대비 효과
   - 설치 및 유지보수 비용
   - 팀 교육 및 적응 비용

4. 통합성
   - 기존 도구와의 연동성
   - 워크플로우 통합 가능성
   - 데이터 형식 호환성
6.2 도구 카테고리별 활용법
도구 카테고리:
1. 디버거 (Debugger)
   - 중단점을 이용한 실행 중지
   - 변수 상태 실시간 관찰
   - 호출 스택 및 실행 흐름 추적
   - 조건부 중단점으로 효율성 증대

2. 프로파일러 (Profiler)
   - CPU 사용량 분석
   - 메모리 할당 패턴 추적
   - 함수 호출 빈도 및 시간 측정
   - 병목 지점 시각화

3. 로그 분석기
   - 로그 패턴 분석 및 필터링
   - 시간대별 트렌드 분석
   - 에러 집계 및 분류
   - 알람 및 알림 설정

4. 모니터링 도구
   - 실시간 시스템 상태 감시
   - 임계값 기반 알림
   - 대시보드를 통한 시각화
   - 히스토리 데이터 분석
7. 팀 협업 프로세스
👥 효과적인 협업 디버깅
7.1 역할 분담 전략
팀 역할 정의:
1. 디버깅 리더
   - 전체 프로세스 조율
   - 우선순위 및 방향 결정
   - 팀원 간 작업 분배
   - 진행 상황 추적 및 보고

2. 기술 전문가
   - 특정 영역별 심화 분석
   - 도구 활용 및 기술 가이드
   - 복잡한 문제 해결 지원
   - 기술적 의사결정 자문

3. 정보 수집 담당
   - 로그 및 데이터 수집
   - 환경 정보 정리
   - 재현 시나리오 작성
   - 문서화 및 기록 관리

4. 테스트 담당
   - 가설 검증 실험 수행
   - 해결책 효과 검증
   - 회귀 테스트 실행
   - 품질 보증 관리
7.2 커뮤니케이션 프로토콜
효과적인 소통 방법:
1. 정기 동기화
   - 일정 시간마다 진행 상황 공유
   - 새로운 발견사항 즉시 전파
   - 막힌 부분 및 도움 요청
   - 다음 단계 계획 합의

2. 표준화된 보고
   - 일관된 형식의 상황 보고
   - 객관적 사실과 주관적 추측 구분
   - 시간 정보 포함 (언제, 얼마나)
   - 액션 아이템 및 담당자 명시

3. 지식 공유
   - 발견한 정보 즉시 공유
   - 시도한 방법 및 결과 기록
   - 유용한 도구 및 방법 전파
   - 실패 경험도 포함해서 공유
7.3 협업 도구 활용
협업 도구 카테고리:
1. 실시간 커뮤니케이션
   - 채팅 도구 (Slack, Teams 등)
   - 화상 회의 (Zoom, Meet 등)
   - 화면 공유 및 원격 협업
   - 음성 채널 상시 연결

2. 문서 협업
   - 공유 문서 (Google Docs, Notion 등)
   - 위키 시스템 (Confluence, GitBook 등)
   - 버전 관리 (Git, SVN 등)
   - 이슈 트래킹 (Jira, GitHub Issues 등)

3. 코드 협업
   - 코드 공유 (GitHub, GitLab 등)
   - 코드 리뷰 시스템
   - 라이브 코딩 (VS Code Live Share 등)
   - 원격 개발 환경
8. 학습 및 문서화
📚 지속적인 개선
8.1 개인 학습 전략
학습 방법론:
1. 경험 기반 학습
   - 각 디버깅 경험 상세 기록
   - 성공/실패 요인 분석
   - 개선점 및 교훈 정리
   - 개인 노하우 데이터베이스 구축

2. 이론 보완 학습
   - 관련 기술 깊이 있게 학습
   - 디버깅 방법론 연구
   - 도구 사용법 마스터
   - 모범 사례 벤치마킹

3. 실습 중심 학습
   - 의도적으로 문제 상황 생성
   - 다양한 도구 실험 및 비교
   - 팀원과 페어 디버깅
   - 오픈소스 프로젝트 기여
8.2 팀 지식 관리
지식 관리 체계:
1. 케이스 스터디 아카이브
   - 주요 디버깅 사례 정리
   - 문제별 해결 패턴 분류
   - 검색 가능한 형태로 저장
   - 정기적 리뷰 및 업데이트

2. 베스트 프랙티스 가이드
   - 팀 표준 디버깅 프로세스
   - 도구 사용 가이드라인
   - 주의사항 및 함정 목록
   - 효율적인 방법 모음

3. 교육 및 훈련 프로그램
   - 신입 팀원 온보딩 프로그램
   - 정기적인 디버깅 워크샵
   - 도구 교육 세션
   - 외부 전문가 초청 세미나
8.3 문서화 모범 사례
효과적인 문서화:
1. 구조화된 문서 작성
   - 템플릿 활용으로 일관성 확보
   - 계층적 정보 구조 (요약 → 상세)
   - 검색 가능한 키워드 포함
   - 시각적 요소 활용 (그래프, 차트)

2. 실용적인 내용 포함
   - 재현 가능한 단계별 가이드
   - 구체적인 명령어 및 설정값
   - 스크린샷 및 예시 포함
   - 관련 링크 및 참고 자료

3. 지속적인 업데이트
   - 정기적인 문서 검토 및 갱신
   - 피드백 반영 및 개선
   - 변경 이력 관리
   - 사용 빈도에 따른 우선순위 조정
🎯 Roo Code 디버그 모드 실행 체크리스트
문제 발생 시 즉시 실행

 DETECT: 문제 증상을 명확하고 구체적으로 정의
 EXTRACT: 관련 정보를 체계적으로 수집 및 정리
 REASON: 논리적 가설을 우선순위별로 수립
 INVESTIGATE: 각 가설을 과학적 방법으로 검증
 VERIFY: 해결책의 실제 효과를 다각도로 확인
 EDUCATE: 경험을 문서화하고 팀과 공유

프로세스 품질 관리

 주관적 추측보다는 객관적 데이터에 기반한 분석
 한 번에 하나의 변수만 변경하여 테스트
 모든 가설과 실험 결과를 상세히 기록
 팀원과 정기적으로 진행 상황 공유

도구 및 환경 준비

 문제 유형에 적합한 디버깅 도구 선택
 안전한 테스트 환경 구성
 백업 및 롤백 계획 수립
 모니터링 및 알림 시스템 활성화

🚀 주니어 개발자를 위한 범용 디버깅 가이드
1. 디버깅은 과학적 탐구입니다

가설: "아마도 이것 때문일 것이다"라고 추측
실험: 가설을 증명하거나 반박할 수 있는 테스트 설계
관찰: 실험 결과를 객관적으로 기록
결론: 증거에 기반해서만 결론 도출

2. 체계적 접근이 빠른 해결의 지름길입니다

무작정 코드를 고치려 하지 말고 문제를 정확히 이해하세요
충분한 정보 수집 없이는 올바른 진단이 불가능합니다
복잡한 문제는 작은 단위로 나누어 해결하세요

3. 도구를 현명하게 활용하세요

각 상황에 맞는 적절한 도구를 선택하세요
도구 사용법을 제대로 익혀서 효율성을 높이세요
여러 도구를 조합해서 다각도로 분석하세요

4. 혼자가 아닌 팀으로 해결하세요

막힐 때는 주저하지 말고 도움을 요청하세요
발견한 정보는 즉시 팀과 공유하세요
해결 과정을 문서화해서 팀 지식으로 축적하세요

5. 실패도 소중한 학습 기회입니다

틀린 가설도 중요한 정보입니다
시도했던 방법들을 모두 기록해두세요
같은 실수를 반복하지 않도록 예방책을 마련하세요